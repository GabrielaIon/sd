import random
from random import randrange as rand

def BubbleSort(v):
    n = len(v)
    for i in range(n):
        for j in range(n - 1):
            if v[j] > v[j + 1]:
                v[j], v[j + 1] = v[j + 1], v[j]
    return v


def CountSort(arr):
    n = len(arr)
    output = [0] * n
    count = [0] * n
    ans = []
    for i in arr:
        count[ord(i)] += 1
    for i in range(256):
        count[i] += count[i - 1]
    for i in range(len(arr)):
        output[count[ord(arr[i])] - 1] = arr[i]
        count[ord(arr[i])] -= 1
    for i in range(len(arr)):
        ans[i] = output[i]
    return ans


def Interclasare(lst, ldr):
    i = j = 0

    rez = []
    while i < len(lst) and j < len(ldr):
        if lst[i] <= ldr[j]:
            rez.append(lst[i])
            i += 1
        else:
            rez.append(ldr[j])
            j += 1

    rez.extend(lst[i:])
    rez.extend(ldr[j:])

    return rez


def MergeSort(ls):
    if len(ls) <= 1:
        return ls
    else:
        mij = len(ls) // 2
        lst = MergeSort(ls[:mij])
        ldr = MergeSort(ls[mij:])
        return Interclasare(lst, ldr)


def partitierandom(arr, st, dr):
    n = random.randint(st, dr)
    piv = arr[n]


def QuickSort(arr, st, dr):
    if st < dr:
        p = partitierandom(arr, st, dr)
        QuickSort(arr, st, p - 1)
        QuickSort(arr, p + 1, dr)


def partitiemed3(arr, st, dr):
    n = (st + dr) // 2
    if arr[st] <= arr[n] <= arr[dr] or arr[dr] <= arr[n] <= arr[st]:
        piv = arr[n]
    elif arr[n] <= arr[st] <= arr[dr] or arr[dr] <= arr[st] <= arr[n]:
        piv = arr[st]
        n = st
    else:
        piv = arr[dr]
        n = dr


def QuickSort2(arr, st, dr):
    if st < dr:
        p = partitiemed3(arr, st, dr)
        QuickSort2(arr, st, p - 1)
        QuickSort2(arr, p + 1, dr)


def radixsort(arr):
    RADIX = 10
    max = False
    temp, poz = -1, 1
    while not max:
        max = True
        buckets = [list() for _ in range(RADIX)]
        for i in arr:
            temp = i / poz
            buckets[temp % RADIX].append(i)
            if max and temp > 0:
                max = False
        a = 0
        for b in range(RADIX):
            buck = buckets[b]
            for i in buck:
                arr[a] = i
                a += 1
        poz *= RADIX


def RadixSort_b2(arr, k):
    n = len(arr)
    m = max(arr)
    if 2 ** k > m:
        return arr
    bucket = [[], []]
    for i in range(n):
        c = (arr[i] >> k) & 1
        if c == 0:
            bucket[0].append(arr[i])
        else:
            bucket[1].append(arr[i])
    s = []
    s.extend(bucket[0])
    s.extend(bucket[1])
    return RadixSort_b2(s, k + 1)


def test(arr):
    ok = 1
    n = len(arr)
    for i in range(n - 1):
        if arr[i] > arr[i + 1]:
            return 0
    return 1


import time

f = open("sort.in")
nr = int(f.readline())
i = 1
for l in f:
    n = int(l.split()[0])
    m = int(l.split()[1])
    test = open("test.in", "w")
    for j in range(n):
        test.write(str(rand(m)) + " ")
    test.close()

    test = open("test.in", "r")
    lista = []
    lista = test.readline().split()
    for i in range(len(lista)):
        lista[i] = int(lista[i])
    test.close()

    # bubble sort
    start = time.time()
    if len(lista) > 10000:
        print("Nu se poate aplica bubble sort pt aceste numere")
    else:
        sort = BubbleSort(lista)
        final = time.time()
        if test(sort):
            print("Bubble sort pt {} numere mai mici decat {} in {} secunde".format(n, m, final - start))

    # count sort
    start = time.time()
    sort = CountSort(lista)
    final = time.time()
    if test(sort):
        print("Nu se poate aplica count sort pt aceste numere")
        if final - start > 5:
            print("dureaza prea mult.")
        else:
            print(str(final - start) + " secunde")

    # merge sort
    start = time.time()
    sort = MergeSort(lista)
    final = time.time()
    if test(sort):
        print("Nu se poate aplica merge sort pt aceste numere")
        if final - start > 5:
            print("dureaza prea mult.")
        else:
            print(str(final - start) + " secunde")

    #quicksort
    start = time.time()
    s = QuickSort(lista)
    final = time.time()
    if test(s):
        print("Nu se poate aplica quick sort pt aceste numere")
        if final - start > 5:
            print("dureaza prea mult.")
        else:
            print(str(final - start) + " secunde")

    ### quick sort mm
    start = time.time()
    s = QuickSort2(lista)
    final = time.time()
    if test(s):
        print("quick sort in pivot mediana din 3 pentru {} numere mai mici decat {}:".format(n, m), end=" ")
        if final - start > 5:
            print("dureaza prea mult.")
        else:
            print(str(final - start) + " secunde")
    # radix sort b2
    start = time.time()
    s = RadixSort_b2(lista, 0)
    final = time.time()
    if test(s):
        print("Nu se poate aplica radix sort pt aceste numere")
        if final - start > 5:
            print("dureaza prea mult.")
        else:
            print(str(final - start) + " secunde")

    # sort
    start = time.time()
    s = sorted(v)
    final = time.time()
    if test(s):
        print("sort pentru {} numere mai mici decat {}: {} secunde".format(n, m, final - start))

